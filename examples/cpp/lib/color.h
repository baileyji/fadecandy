/*
 * Color Utilities
 */

#pragma once

#include "svl/SVL.h"

static inline void hsv2rgb(Vec3 &rgb, float h, float s, float v)
{
    /*
     * Converts an HSV color value to RGB.
     *
     * Normal hsv range is in [0, 1], RGB range is [0, 255].
     * Colors may extend outside these bounds. Hue values will wrap.
     *
     * Based on tinycolor:
     * https://github.com/bgrins/TinyColor/blob/master/tinycolor.js
     * 2013-08-10, Brian Grinstead, MIT License
     */

    h = fmodf(h, 1) * 6.0f;
    if (h < 0) h += 6.0f;

    int i = h;
    float f = h - i;
    float p = v * (1 - s);
    float q = v * (1 - f * s);
    float t = v * (1 - (1 - f) * s);

    switch (i) {
        case 0: rgb[0] = v; rgb[1] = t; rgb[2] = p; break;
        case 1: rgb[0] = q; rgb[1] = v; rgb[2] = p; break;
        case 2: rgb[0] = p; rgb[1] = v; rgb[2] = t; break;
        case 3: rgb[0] = p; rgb[1] = q; rgb[2] = v; break;
        case 4: rgb[0] = t; rgb[1] = p; rgb[2] = v; break;
        case 5: rgb[0] = v; rgb[1] = p; rgb[2] = q; break;
    }
}

static inline void hsv2rgb(Vec3 &rgb, Vec3 hsv)
{
    return hsv2rgb(rgb, hsv[0], hsv[1], hsv[2]);
}


static int CCT_RGB_LUT_TEMPS = {660,     710,     765,     823,     887,     955,    1028,
          1107,    1192,    1284,    1382,    1489,    1603,    1726,
          1859,    2001,    2155,    2321,    2499,    2691,    2897,
          3120,    3359,    3617,    3895,    4194,    4516,    4863,
          5236,    5638,    6071,    6537,    7039,    7580,    8162,
          8789,    9463,   10190,   10972,   11815,   12722,   13699,
         14751,   15883,   17103,   18416,   19830,   21352,   22992,
         24757,   26658,   28705,   30909,   33282,   35837,   38589,
         41551,   44742,   48177,   51876,   55858,   60147,   64765,
         69738,   75092,   80857,   87065,   93750,  100948,  108698,
        117044,  126030,  135707,  146126,  157345,  169426,  182434,
        196440,  211523,  227763,  245250,  264079,  284355,  306187,
        329695,  355008,  382264,  411614,  443216,  477245,  513886,
        553341,  595825,  641571,  690829,  743869,  800981,  862478,
        928697, 1000000};
static float CCT_RGB_LUT = {
    {1., 0., 0.}, {1., 0.14016985, 0.}, {1., 0.21230374, 0.}, {1., 0.26717536, 0.}, {1., 0.3145161, 0.},
    {1., 0.35755721, 0.}, {1., 0.39778565, 0.}, {1., 0.43599778, 0.}, {1., 0.47265615, 0.}, {1., 0.50804043, 0.},
    {1., 0.54232094, 0.}, {1., 0.57559836, 0.06712699}, {1., 0.60792695, 0.12148562}, {1., 0.63932916, 0.16987189},
    {1., 0.66980532, 0.21711989}, {1., 0.69934044, 0.26464529}, {1., 0.72790927, 0.31295754},
    {1., 0.75548016, 0.36220351}, {1., 0.78201811, 0.41235024}, {1., 0.8074872, 0.46326353},
    {1., 0.83185251, 0.51474815}, {1., 0.85508178, 0.56657131}, {1., 0.87714668, 0.61847785},
    {1., 0.89802397, 0.6702009}, {1., 0.91769661, 0.72147004}, {1., 0.93615469, 0.7720179},
    {1., 0.95339642, 0.82158607}, {1., 0.96942886, 0.86993044}, {1., 0.98426857, 0.91682635},
    {1., 0.99794181, 0.96207322}, {0.98962441, 1., 0.99506609}, {0.95514448, 0.9761013, 1.},
    {0.92050875, 0.95030033, 1.}, {0.88999091, 0.92720423, 1.}, {0.8630538, 0.90650976, 1.},
    {0.83923858, 0.88795271, 1.}, {0.81815111, 0.87130116, 1.}, {0.7994512, 0.85635031, 1.},
    {0.78284425, 0.84291845, 1.}, {0.76807442, 0.8308439, 1.}, {0.75491909, 0.81998249, 1.},
    {0.74318426, 0.81020553, 1.}, {0.73270072, 0.8013981, 1.}, {0.72332069, 0.79345762, 1.},
    {0.71491508, 0.78629251, 1.}, {0.70737101, 0.77982112, 1.}, {0.70058972, 0.77397063, 1.},
    {0.69448474, 0.76867619, 1.}, {0.68898028, 0.76388003, 1.}, {0.68400989, 0.75953071, 1.},
    {0.6795152, 0.75558246, 1.}, {0.67544491, 0.75199452, 1.}, {0.67175386, 0.74873061, 1.},
    {0.66840226, 0.7457584, 1.}, {0.66535497, 0.74304907, 1.}, {0.66258095, 0.74057694, 1.},
    {0.66005269, 0.73831906, 1.}, {0.65774583, 0.73625496, 1.}, {0.65563871, 0.73436631, 1.},
    {0.65371206, 0.7326367, 1.}, {0.65194871, 0.73105143, 1.}, {0.65033334, 0.72959731, 1.},
    {0.64885222, 0.72826248, 1.}, {0.6474931, 0.72703627, 1.}, {0.64624495, 0.72590909, 1.},
    {0.64509786, 0.72487226, 1.}, {0.64404294, 0.72391796, 1.}, {0.64307215, 0.72303911, 1.},
    {0.64217823, 0.72222931, 1.}, {0.64135462, 0.72148276, 1.}, {0.6405954, 0.72079417, 1.},
    {0.63989518, 0.72015876, 1.}, {0.63924906, 0.71957217, 1.}, {0.63865261, 0.71903044, 1.},
    {0.63810179, 0.71852995, 1.}, {0.6375929, 0.71806739, 1.}, {0.63712259, 0.71763976, 1.},
    {0.63668778, 0.71724428, 1.}, {0.63628567, 0.71687845, 1.}, {0.63591369, 0.71653993, 1.},
    {0.6355695, 0.71622663, 1.}, {0.63525093, 0.71593659, 1.}, {0.63495601, 0.71566802, 1.},
    {0.63468292, 0.71541928, 1.}, {0.63442999, 0.71518887, 1.}, {0.63419569, 0.7149754, 1.},
    {0.63397862, 0.71477759, 1.}, {0.63377746, 0.71459426, 1.}, {0.63359103, 0.71442433, 1.},
    {0.63341822, 0.71426679, 1.}, {0.63325801, 0.71412073, 1.}, {0.63310947, 0.7139853, 1.},
    {0.63297174, 0.7138597, 1.}, {0.632844, 0.71374321, 1.}, {0.63272553, 0.71363516, 1.},
    {0.63261564, 0.71353493, 1.}, {0.6325137, 0.71344195, 1.}, {0.63241913, 0.71335568, 1.},
    {0.63233139, 0.71327564, 1.}, {0.63224999, 0.71320136, 1.}};

static inline void cct_to_rgb(Vec3 &rgb, float cct) {
    int ndx;
    if (cct < 670)
        ndx=0;
    else if (cct > 1e6)
        ndx=LUT_LEN-1;
    else
        ndx = binary_search(CCT_RGB_LUT_TEMPS, (int) cct);
    for (int i=0;i<3;i++)
        rgb[i]=CCT_RGB_LUT[i, ndx];
}


int binary_search(int A[], int key, int imin, int imax) {
    int MAXN=imax-1;
    imin=0;

    while (imax >= imin) {          // continue searching while [imin,imax] is not empty
      int imid = (imin+imax)/2;     // calculate the midpoint for roughly equal partition
      if(A[imid] == key)            // key found at index imid
        return imid;
      else if (A[imid] < key)       // change min index to search upper subarray
        imin = imid + 1;
      else                          // change max index to search lower subarray
        imax = imid - 1;
    }
    if (imax <= 0) {
        return 0;
    } else if (imin >= MAXN) {
        return MAXN;
    } else if ((key - A[imax]) < (A[imin] - key)) {
        return imax;
    } else {
        return imin;
    }
}
